{"ast":null,"code":"const bcrypt = require('bcrypt');\nconst dictionaryWords = ['password', '123456', 'qwerty']; // Example dictionary words\n\nfunction isPasswordValid(password) {\n  const minLength = 8;\n  const hasUpperCase = /[A-Z]/.test(password);\n  const hasLowerCase = /[a-z]/.test(password);\n  const hasDigit = /[0-9]/.test(password);\n  const hasSpecialChar = /[!@#$%^&*(),.?\":{}|<>]/.test(password);\n  const isLongEnough = password.length >= minLength;\n  const isNotInDictionary = !dictionaryWords.includes(password.toLowerCase());\n  return isLongEnough && hasUpperCase && hasLowerCase && hasDigit && hasSpecialChar && isNotInDictionary;\n}\nconst passwordHistory = []; // This should be stored in a secure database in a real application\n\nfunction isPasswordInHistory(password) {\n  // Assuming passwordHistory stores hashed passwords\n  const hashedPassword = bcrypt.hashSync(password, 10);\n  return passwordHistory.some(histPassword => bcrypt.compareSync(password, histPassword));\n}\nfunction addPasswordToHistory(password) {\n  const hashedPassword = bcrypt.hashSync(password, 10);\n  passwordHistory.push(hashedPassword);\n  if (passwordHistory.length > 3) {\n    passwordHistory.shift(); // Keep only the last 3 passwords\n  }\n}\nconst loginAttempts = {}; // Structure: { email: { attempts: number, lastAttempt: timestamp, blockedUntil: timestamp } }\n\nconst MAX_ATTEMPTS = 3;\nconst BLOCK_TIME_MS = 1 * 60 * 60 * 1000; // 1 hour in milliseconds\n\nfunction recordLoginAttempt(email, success) {\n  const now = Date.now();\n  if (!loginAttempts[email]) {\n    loginAttempts[email] = {\n      attempts: 0,\n      lastAttempt: now,\n      blockedUntil: 0\n    };\n  }\n  if (now < loginAttempts[email].blockedUntil) {\n    return false; // Account is currently blocked\n  }\n  if (success) {\n    loginAttempts[email] = {\n      attempts: 0,\n      lastAttempt: now,\n      blockedUntil: 0\n    }; // Reset on successful login\n  } else {\n    loginAttempts[email].attempts++;\n    loginAttempts[email].lastAttempt = now;\n    if (loginAttempts[email].attempts >= MAX_ATTEMPTS) {\n      loginAttempts[email].blockedUntil = now + BLOCK_TIME_MS; // Block account\n      return false; // Account is now blocked\n    }\n  }\n  return true;\n}\nmodule.exports = {\n  isPasswordValid,\n  isPasswordInHistory,\n  addPasswordToHistory,\n  recordLoginAttempt\n};","map":{"version":3,"names":["bcrypt","require","dictionaryWords","isPasswordValid","password","minLength","hasUpperCase","test","hasLowerCase","hasDigit","hasSpecialChar","isLongEnough","length","isNotInDictionary","includes","toLowerCase","passwordHistory","isPasswordInHistory","hashedPassword","hashSync","some","histPassword","compareSync","addPasswordToHistory","push","shift","loginAttempts","MAX_ATTEMPTS","BLOCK_TIME_MS","recordLoginAttempt","email","success","now","Date","attempts","lastAttempt","blockedUntil","module","exports"],"sources":["C:/Users/vales/OneDrive/שולחן העבודה/לימודים/שנה ג/סמס ק/אבטחת מחשבים/‏‏compsecprojectcopy/frontend/src/passwordValidation.js"],"sourcesContent":["const bcrypt = require('bcrypt');\r\n\r\nconst dictionaryWords = ['password', '123456', 'qwerty']; // Example dictionary words\r\n\r\nfunction isPasswordValid(password) {\r\n    const minLength = 8;\r\n    const hasUpperCase = /[A-Z]/.test(password);\r\n    const hasLowerCase = /[a-z]/.test(password);\r\n    const hasDigit = /[0-9]/.test(password);\r\n    const hasSpecialChar = /[!@#$%^&*(),.?\":{}|<>]/.test(password);\r\n    const isLongEnough = password.length >= minLength;\r\n    const isNotInDictionary = !dictionaryWords.includes(password.toLowerCase());\r\n\r\n    return isLongEnough && hasUpperCase && hasLowerCase && hasDigit && hasSpecialChar && isNotInDictionary;\r\n}\r\n\r\nconst passwordHistory = []; // This should be stored in a secure database in a real application\r\n\r\nfunction isPasswordInHistory(password) {\r\n    // Assuming passwordHistory stores hashed passwords\r\n    const hashedPassword = bcrypt.hashSync(password, 10);\r\n    return passwordHistory.some(histPassword => bcrypt.compareSync(password, histPassword));\r\n}\r\n\r\nfunction addPasswordToHistory(password) {\r\n    const hashedPassword = bcrypt.hashSync(password, 10);\r\n    passwordHistory.push(hashedPassword);\r\n    if (passwordHistory.length > 3) {\r\n        passwordHistory.shift(); // Keep only the last 3 passwords\r\n    }\r\n}\r\n\r\nconst loginAttempts = {}; // Structure: { email: { attempts: number, lastAttempt: timestamp, blockedUntil: timestamp } }\r\n\r\nconst MAX_ATTEMPTS = 3;\r\nconst BLOCK_TIME_MS = 1 * 60 * 60 * 1000; // 1 hour in milliseconds\r\n\r\nfunction recordLoginAttempt(email, success) {\r\n    const now = Date.now();\r\n    if (!loginAttempts[email]) {\r\n        loginAttempts[email] = { attempts: 0, lastAttempt: now, blockedUntil: 0 };\r\n    }\r\n\r\n    if (now < loginAttempts[email].blockedUntil) {\r\n        return false; // Account is currently blocked\r\n    }\r\n\r\n    if (success) {\r\n        loginAttempts[email] = { attempts: 0, lastAttempt: now, blockedUntil: 0 }; // Reset on successful login\r\n    } else {\r\n        loginAttempts[email].attempts++;\r\n        loginAttempts[email].lastAttempt = now;\r\n\r\n        if (loginAttempts[email].attempts >= MAX_ATTEMPTS) {\r\n            loginAttempts[email].blockedUntil = now + BLOCK_TIME_MS; // Block account\r\n            return false; // Account is now blocked\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nmodule.exports = {\r\n    isPasswordValid,\r\n    isPasswordInHistory,\r\n    addPasswordToHistory,\r\n    recordLoginAttempt\r\n};\r\n"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAEhC,MAAMC,eAAe,GAAG,CAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC;;AAE1D,SAASC,eAAeA,CAACC,QAAQ,EAAE;EAC/B,MAAMC,SAAS,GAAG,CAAC;EACnB,MAAMC,YAAY,GAAG,OAAO,CAACC,IAAI,CAACH,QAAQ,CAAC;EAC3C,MAAMI,YAAY,GAAG,OAAO,CAACD,IAAI,CAACH,QAAQ,CAAC;EAC3C,MAAMK,QAAQ,GAAG,OAAO,CAACF,IAAI,CAACH,QAAQ,CAAC;EACvC,MAAMM,cAAc,GAAG,wBAAwB,CAACH,IAAI,CAACH,QAAQ,CAAC;EAC9D,MAAMO,YAAY,GAAGP,QAAQ,CAACQ,MAAM,IAAIP,SAAS;EACjD,MAAMQ,iBAAiB,GAAG,CAACX,eAAe,CAACY,QAAQ,CAACV,QAAQ,CAACW,WAAW,CAAC,CAAC,CAAC;EAE3E,OAAOJ,YAAY,IAAIL,YAAY,IAAIE,YAAY,IAAIC,QAAQ,IAAIC,cAAc,IAAIG,iBAAiB;AAC1G;AAEA,MAAMG,eAAe,GAAG,EAAE,CAAC,CAAC;;AAE5B,SAASC,mBAAmBA,CAACb,QAAQ,EAAE;EACnC;EACA,MAAMc,cAAc,GAAGlB,MAAM,CAACmB,QAAQ,CAACf,QAAQ,EAAE,EAAE,CAAC;EACpD,OAAOY,eAAe,CAACI,IAAI,CAACC,YAAY,IAAIrB,MAAM,CAACsB,WAAW,CAAClB,QAAQ,EAAEiB,YAAY,CAAC,CAAC;AAC3F;AAEA,SAASE,oBAAoBA,CAACnB,QAAQ,EAAE;EACpC,MAAMc,cAAc,GAAGlB,MAAM,CAACmB,QAAQ,CAACf,QAAQ,EAAE,EAAE,CAAC;EACpDY,eAAe,CAACQ,IAAI,CAACN,cAAc,CAAC;EACpC,IAAIF,eAAe,CAACJ,MAAM,GAAG,CAAC,EAAE;IAC5BI,eAAe,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7B;AACJ;AAEA,MAAMC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;;AAE1B,MAAMC,YAAY,GAAG,CAAC;AACtB,MAAMC,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;;AAE1C,SAASC,kBAAkBA,CAACC,KAAK,EAAEC,OAAO,EAAE;EACxC,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;EACtB,IAAI,CAACN,aAAa,CAACI,KAAK,CAAC,EAAE;IACvBJ,aAAa,CAACI,KAAK,CAAC,GAAG;MAAEI,QAAQ,EAAE,CAAC;MAAEC,WAAW,EAAEH,GAAG;MAAEI,YAAY,EAAE;IAAE,CAAC;EAC7E;EAEA,IAAIJ,GAAG,GAAGN,aAAa,CAACI,KAAK,CAAC,CAACM,YAAY,EAAE;IACzC,OAAO,KAAK,CAAC,CAAC;EAClB;EAEA,IAAIL,OAAO,EAAE;IACTL,aAAa,CAACI,KAAK,CAAC,GAAG;MAAEI,QAAQ,EAAE,CAAC;MAAEC,WAAW,EAAEH,GAAG;MAAEI,YAAY,EAAE;IAAE,CAAC,CAAC,CAAC;EAC/E,CAAC,MAAM;IACHV,aAAa,CAACI,KAAK,CAAC,CAACI,QAAQ,EAAE;IAC/BR,aAAa,CAACI,KAAK,CAAC,CAACK,WAAW,GAAGH,GAAG;IAEtC,IAAIN,aAAa,CAACI,KAAK,CAAC,CAACI,QAAQ,IAAIP,YAAY,EAAE;MAC/CD,aAAa,CAACI,KAAK,CAAC,CAACM,YAAY,GAAGJ,GAAG,GAAGJ,aAAa,CAAC,CAAC;MACzD,OAAO,KAAK,CAAC,CAAC;IAClB;EACJ;EACA,OAAO,IAAI;AACf;AAEAS,MAAM,CAACC,OAAO,GAAG;EACbnC,eAAe;EACfc,mBAAmB;EACnBM,oBAAoB;EACpBM;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}